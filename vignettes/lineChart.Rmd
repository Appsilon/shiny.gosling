---
title: "4. Creating a line chart with shiny.gosling"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{4. Creating a line chart with shiny.gosling}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
runtime: shiny
---

```{r, include=FALSE, eval=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This is a Shiny app written in R that uses the shiny and shiny.gosling packages to create an interactive line chart visualization of genomic data.

## Call required libraries.

```{r setup, message=FALSE, eval=FALSE}
require(shiny)
require(shiny.gosling)
```

## Loading the url to a multivec dataset

The track_data function is used to create a data object named view1_data.
The data is loaded from the specified URL, which points to a multivec data source.
The data is structured as a matrix with rows representing different samples, columns representing positions, and values representing peak measurements.
The categories parameter specifies a list with a single category name ("sample 1").

"Multivec" is a term used in genomics to refer to a specific type of data format used for representing and visualizing multi-dimensional numerical data across genomic coordinates. It's commonly used for representing data like ChIP-seq, ATAC-seq, Hi-C, and other genomic experiments where signals or measurements are collected at various genomic positions.

Multivec data is essentially a matrix where rows correspond to different genomic positions or regions, and columns correspond to different samples or experiments. Each entry in the matrix represents a value associated with a specific genomic position and sample. The genomic positions along the rows of the matrix are usually represented as chromosomal coordinates (chromosome name and base pair position). This allows the data to be aligned with the genome, enabling accurate visualization and analysis. There are different tools and file formats that support multivec data, allowing researchers to work with and visualize this type of data. The bigWig and bedGraph formats are commonly used for representing multivec data. Visualization tools and libraries like the UCSC Genome Browser, IGV (Integrative Genomics Viewer), and libraries like "shiny.gosling" can render multivec data visualizations.

Here are some resources and links where you can learn more about multivec data and how it's used in genomics research:

UCSC Genome Browser:

The UCSC Genome Browser is a widely used tool for visualizing genomic data, including multivec data.
[Tutorial on visualizing multivec data in the UCSC Genome Browser](https://genome.ucsc.edu/goldenPath/help/bigWig.html)

IGV (Integrative Genomics Viewer):

IGV is another popular genome visualization tool that supports multivec data.
[Tutorial on loading and visualizing multivec data in IGV](https://software.broadinstitute.org/software/igv/multivec)

BedGraph and BigWig Formats:

These are common file formats used for representing multivec data.
[Explanation of the BedGraph format](https://genome.ucsc.edu/goldenPath/help/bedgraph.html)
[Explanation of the BigWig format](https://genome.ucsc.edu/goldenPath/help/bigWig.html)

```{r, reading-data, eval=FALSE}

# Create data object ----
view1_data <- track_data(
  url = "https://resgen.io/api/v1/tileset_info/?d=UvVPeLHuRDiYA3qwFlm7xQ",
  type = "multivec",
  row = "sample",
  column = "position",
  value = "peak",
  categories = list("sample 1")
)
```

## Creating a Single Track

view1_x and view1_y are visual channel definitions.
view1_x specifies that the x-axis should represent the "position" field using genomic coordinates and be positioned at the bottom.
view1_y specifies that the y-axis should represent the "peak" field as a quantitative value and be positioned on the right.

The add_single_track function is used to create a single line chart track visualization.
The width and height parameters determine the dimensions of the plot.
The data source is specified as view1_data, and the visualization uses a "line" mark.
The x and y visual channels are defined using view1_x and view1_y.
The size of the line is set using the visual_channel_size function.

```{r single_track, eval=FALSE}

# Create visual channels ----
view1_x <- visual_channel_x(
  field = "position", type = "genomic", axis = "bottom"
)

view1_y <- visual_channel_y(
  field = "peak", type = "quantitative", axis = "right"
)

# Create single track ----
single_track <- add_single_track(
  width = 800,
  height = 180,
  data = view1_data,
  mark = "line",
  x = view1_x,
  y = view1_y,
  size = visual_channel_size(
    value = 2
  )
)
```

## Composing the track

The compose_view function is used to create a composed view that contains the single line chart track.
The layout of the view is specified as "linear".

The arrange_views function arranges the composed view created earlier.
The title and subtitle for the arrangement are specified.
The arranged view is named single_composed_views.

```{r, compose, eval=FALSE}

# Compose the track ----
single_composed_view <- compose_view(
  tracks = single_track,
  layout = "linear"
)

# Arrange the view above ----
single_composed_views <- arrange_views(
  title = "Basic Marks: line",
  subtitle = "This is a simple line chart.",
  views = single_composed_view
)
```

## Shiny App ui

The navbarPage function creates a navigation bar at the top of the user interface.
Within the navigation bar, there is a single tab panel named "Line Chart."
Inside the tab panel, the use_gosling function is used to incorporate the shiny.gosling package.
The fluidPage function is used to create a fluid layout within the tab panel.
Two columns are defined: one for the goslingOutput and another for action buttons.

```{r, ui, eval=FALSE}

ui <- navbarPage(
  title = "shiny.gosling",
  tabPanel(
    "Line Chart",
    use_gosling(),
    fluidPage(
      width = 12,
      fluidRow(
        column(
          width = 8,
          goslingOutput("gosling_plot_test")
        ),
        column(
          width = 4,
          fluidRow(
            column(
              2,
              actionButton(
                "download_png",
                "PNG",
                icon = icon("cloud-arrow-down")
              )
            ),
            column(
              2,
              actionButton(
                "download_pdf",
                "PDF",
                icon = icon("cloud-arrow-down")
              )
            )
          )
        )
      )
    )
  )
)
```

## Shiny App server

The server logic is defined using the server function.
The observeEvent functions are used to respond to button clicks and user interactions.
Clicking the "PNG" or "PDF" buttons triggers the respective download action for the visualization.
The output$gosling_plot_test function uses renderGosling to render the composed view using the gosling function from the shiny.gosling package.

```{r, server, eval=FALSE}

server <- function(input, output, session) {

  observeEvent(input$download_png, {
    export_png(component_id = "sars_cov2")
  })

  observeEvent(input$download_pdf, {
    export_pdf(component_id = "sars_cov2")
  })

  observeEvent(input$zoom_out, {
    zoom_to_extent(
      component_id = "sars_cov2",
      view_id = "view2_track1"
    )
  })

  output$gosling_plot_test <- renderGosling({
    gosling(
      component_id = "sars_cov2",
      single_composed_views,
      clean_braces = TRUE
    )
  })
}

shinyApp(ui, server)
```

![](lineChart.png){width=500px}

## Session Info

```{r session_info}

sessionInfo()
```
